package bma;


import java.util.Random;

/**
 * Key generator.
 * 
 * FIXME: I have no idea what crazyOp() does.
 * Please let me know if you recognize that algorithm.
 */
public final class BlizzCrypt
{

    public BlizzCrypt()
    {
    }

    public static void xorEncryptArray(byte message[], byte key[])
    {
        for(int i = key.length - 1; i >= 0; i--)
            message[i] ^= key[i];

    }

    /**
     * Generates an array of random bytes.
     * 
     * To protect against potentially weak PRNGs of J2ME implementations, 
     * the function first generates random numbers in 64 byte blocks
     * and fills the result array with SHA-160 hashes of these blocks.
     * It should be sufficient for an emulator with a high quality PRNG
     * to leave out the hashing part. 
     * 
     * @param size number of random bytes to be generated
     * @return array of $size random bytes ¡Ê [0..255] 
     */
    public static byte[] genRandomBytes(int size)
    {
        byte result[] = new byte[size];
        Random random = new Random(System.currentTimeMillis());
        HashSHA1 sha_hash = new HashSHA1();
        for(int k = 0; k < size; k += 20)
        {
            int i1 = Math.min(20, size - k);
            byte abyte1[] = new byte[64];
            for(int j1 = 63; j1 >= 0; j1--)
                abyte1[j1] = (byte)(Math.abs(random.nextInt()) % 256);

            sha_hash.initContext();
            sha_hash.updateEngine(abyte1, 0, 64);
            abyte1 = sha_hash.getDigest();
            System.arraycopy(abyte1, 0, result, k, i1);
        }

        return result;
    }

    /**
     * gets called (only) by the Network class for the authenticator registration
     * @param abyte0: array of 55 bytes, generated by {@link Authenticator#generateEnrollmentMash()} 
     */
    public static void prepareEnrollmentBytes(byte abyte0[])
    {
        round_counter = 0;
        byte abyte1[];
        (abyte1 = new byte[abyte0.length + 1])[0] = 1;
        System.arraycopy(abyte0, 0, abyte1, 1, abyte0.length);
        abyte0 = abyte1;
        OTP = new int[32];
        int i = OTP.length - 1;
        for(int k = abyte0.length - 1; k >= 0; k -= 4)
        {
            int x = 0;
            for(int j1 = 3; j1 >= 0; j1--)
                if(k - j1 >= 0)
                    x = (x <<= 8) | abyte0[k - j1] & 0xff;

            OTP[i] = x;
            i--;
        }

    }

    static void intToBytes(int num, byte result[], int offset)
    {
        for(int i = offset + 3; i >= offset; i--)
        {
            byte b = (byte)(num & 0xff);
            result[i] = b;
            num >>>= 8;
        }

    }
    
    public static int round()
    {
        if(round_counter == 0)
        {
            foo_int_array_1 = new int[33];
            crazyOp(foo_int_array_1, OTP, funky_consts_2, funky_consts_1, 0x31d17657L);
        } else
        if(round_counter == 1)
        {
            foo_int_array_2 = new int[32];
            System.arraycopy(OTP, 0, foo_int_array_2, 0, 32);
        } else
        if(round_counter < 10)
            crazyOp(foo_int_array_1, OTP, OTP, funky_consts_1, 0x31d17657L);
        else
        if(round_counter == 10)
            crazyOp(foo_int_array_1, OTP, foo_int_array_2, funky_consts_1, 0x31d17657L);
        else
        if(round_counter == 11)
        {
            setArrayZero(foo_int_array_2);
            foo_int_array_2[foo_int_array_2.length - 1] = 1;
            crazyOp(foo_int_array_1, OTP, foo_int_array_2, funky_consts_1, 0x31d17657L);
        }
        round_counter++;
        return round_counter;
    }

    public static byte[] getOTPBytes()
    {
        byte abyte0[] = new byte[128];
        for(int i = 0; i < OTP.length; i++)
            intToBytes(OTP[i], abyte0, i * 4);

        return abyte0;
    }

    private static void setArrayZero(int ai[])
    {
        for(int i = 0; i < ai.length; i++)
            ai[i] = 0;

    }

    /**
     * OMG!
     * 
     * @param a1 kittens
     * @param a2 ponies
     * @param a3 unicorns
     * @param a4 pixies
     * @param lfoo hacksaw
     */
    private static void crazyOp(int a1[], int a2[], int a3[], int a4[], long lfoo)
    {
        int a4len = a4.length;
        int k = a4len - 1;
        long x1 = (long)a3[a4len - 1] & 0xffffffffL;
        setArrayZero(a1);
        for(int i = a4len; i > 0; i--)
        {
            long x2 = (long)a2[i - 1] & 0xffffffffL;
            long x3 = (((long)a1[a4len] & 0xffffffffL) + (x2 * x1 & 0xffffffffL) & 0xffffffffL) * lfoo & 0xffffffffL;
            long x4 = x2 * x1;
            long x5 = x3 * ((long)a4[a4len - 1] & 0xffffffffL);
            long x6 = ((long)a1[a4len] & 0xffffffffL) + (x4 & 0xffffffffL) + (x5 & 0xffffffffL);
            long x7 = (x4 >>> 32) + (x5 >>> 32) + (x6 >>> 32);
            for(int j = k; j > 0; j--)
            {
                long x8 = x2 * ((long)a3[j - 1] & 0xffffffffL);
                long x9 = x3 * ((long)a4[j - 1] & 0xffffffffL);
                long xA = ((long)a1[j] & 0xffffffffL) + (x8 & 0xffffffffL) + (x9 & 0xffffffffL) + (x7 & 0xffffffffL);
                x7 = (x7 >>> 32) + (x8 >>> 32) + (x9 >>> 32) + (xA >>> 32);
                a1[j + 1] = (int)xA;
            }

            x7 += (long)a1[0] & 0xffffffffL;
            a1[1] = (int)x7;
            a1[0] = (int)(x7 >>> 32);
            if((a4len & 3) == 0)
                Thread.yield();
        }

        if(funkyFunc1(a1, a4))
            funkyFunc2(a1, a4);
        System.arraycopy(a1, 1, a2, 0, a4len);
    }

    private static boolean funkyFunc1(int aint1[], int aint2[])
    {
        if(aint1[0] != 0)
            return true;
        for(int i = 0; i < aint2.length; i++)
        {
            long l1 = (long)aint1[i + 1] & 0xffffffffL;
            long l2 = (long)aint2[i] & 0xffffffffL;
            if(l1 > l2)
                return true;
            if(l2 > l1)
                return false;
        }

        return true;
    }

    private static void funkyFunc2(int aint1[], int aint2[])
    {
        int i = 0;
        for(int k = aint1.length - 1; k >= 1; k--)
        {
            long l1 = (long)aint1[k] & 0xffffffffL;
            long l2 = (long)aint2[k - 1] & 0xffffffffL;
            l1 = (l1 - l2) + (long)i;
            aint1[k] = (int)l1;
            i = (int)(l1 >> 63);
        }

    }

    /**
     * CAUTION! Hungry raptors!
     */
    private static final int funky_consts_1[] = {
        0x955e4bd9, 0x89f3917d, 0x2f15544a, 0x7e0504eb, 0x9d7bb66b, 0x6f8a2fe4, 0x70e453c7, 0x79200e5e, 0x3ad2e43a, 0x02d06c4a, 
        0xdbd8d328, 0xf1a426b8, 0x3658e88b, 0xfd949b2a, 0xf4eaf300, 0x54673a14, 0x19a250fa, 0x4cc1278d, 0x12855b5b, 0x25818d16, 
        0x2c6e6ee2, 0xab4a350d, 0x401d78f6, 0xddb99711, 0xe72626b4, 0x8bd8b5b0, 0xb7f3acf9, 0xea3c9e00, 0x05fee59e, 0x19136cdb, 
        0x7c83f2ab, 0x8b0a2a99
    };
    
    /**
     * "Help! I am trapped in a video game factory!"
     */
    private static final int funky_consts_2[] = {
        0x9403ecf6, 0x24ab7e62, 0xf06bb765, 0xa9a7d8e3, 0x56e338ec, 0xa5e418fa, 0x568d53fa, 0x61d2fa63, 0x6fd56ce5, 0x7f9bdd64, 
        0x7b4fdf6b, 0x0345627f, 0x06ff163c, 0x69e0d8ee, 0xf28532b3, 0x755bec12, 0x26fd4162, 0xa79f1268, 0xcdefce44, 0x4bb0e8f3, 
        0xe3daca30, 0x93e4852b, 0xb7e14266, 0xd5c3e3af, 0x7a33cdde, 0x30b02806, 0x1ff386d5, 0xda74d118, 0xdc065349, 0x743e9227, 
        0x95457c7b, 0x57205fb6
    };
    
    static int foo_int_array_1[];
    static int foo_int_array_2[];
    static int OTP[];
    static int round_counter = -1;

}